# Architecture Design Document

This document describes the overall architecture and system design of the NMS Optimizer Service, including the rationale behind key design choices.

## 1. Overview

The NMS Optimizer Service is a web-based application designed to help players of the game "No Man's Sky" to optimize the layout of their technology modules for maximum performance. The service is implemented as a client-server application. The backend is a Python Flask server that exposes a REST API and a WebSocket interface. The frontend is a web-based client that interacts with the backend to get optimized layouts.

## 2. System Architecture

The system is composed of the following main components:

*   **Web Server**: A Flask-based web server that handles HTTP requests and WebSocket connections.
*   **Optimization Engine**: The core component of the application that performs the layout optimization.
*   **Data Store**: A collection of JSON and Python files that store the game data, such as module definitions, grid layouts, and pre-calculated optimal solutions.

### 2.1. Web Server

The web server is implemented using the Flask web framework and Gunicorn as the WSGI server. It provides the following functionalities:

*   **REST API**: A set of REST endpoints for:
    *   Optimizing a layout (`/optimize`).
    *   Retrieving the technology tree for a specific ship (`/tech_tree/<ship_name>`).
    *   Getting a list of all available ship types (`/platforms`).
    *   Retrieving analytics data (`/analytics/popular_data`).
*   **WebSocket Interface**: A WebSocket endpoint (`/optimize`) for real-time optimization. This allows the server to send progress updates to the client during a long-running optimization process.

### 2.2. Optimization Engine

The optimization engine is the core of the application. It uses a sophisticated multi-step process to find the optimal layout for a given set of modules. The main steps are:

1.  **Solve Map Lookup**: The engine first checks if a pre-calculated optimal solution (a "solve map") exists for the given ship and technology.
2.  **Pattern Matching**: If a solve map is found, the engine uses pattern matching to find the best position for the pattern on the user's grid.
3.  **Opportunity Refinement**: The engine then identifies "opportunity windows" (areas with supercharged slots) and uses either a Machine Learning model or a Simulated Annealing algorithm to refine the placement of modules within that window.
4.  **Simulated Annealing**: If no solve map is found, or if the pattern matching fails, the engine falls back to using a Simulated Annealing algorithm to find a good placement.

### 2.3. Machine Learning Model

The optimization engine uses a pre-trained PyTorch model to predict the optimal placement of modules. The model is a neural network that takes the grid's supercharged slot configuration as input and outputs a probability distribution over all possible module placements. The model is trained on a large dataset of optimal layouts generated by the Simulated Annealing algorithm.

### 2.4. Data Store

The application's data is stored in a collection of JSON and Python files in the `src/data_definitions` directory. This includes:

*   **`grids.py`**: Defines the grid layouts for different ship types.
*   **`modules_data/*.json`**: Contains the data for each module, including its bonus, adjacency requirements, etc.
*   **`solves/*.json`**: Contains the pre-calculated optimal layouts (solve maps).
*   **`recommended_builds.py`**: Contains recommended builds for different ships.

## 3. Deployment

The application is designed to be deployed on the Heroku platform. It uses a `Procfile` to declare the web process that runs the Gunicorn server. The Python version for the Heroku environment is specified in the `.python-version` file.
